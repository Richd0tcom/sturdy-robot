// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: invoice_items.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createInvoiceItem = `-- name: CreateInvoiceItem :one
INSERT INTO invoice_items (
    id, invoice_id, version_id, quantity, 
    unit_price, subtotal
) VALUES (
    uuid_generate_v4(), $1, $2, $3, $4, $5
) RETURNING id, invoice_id, version_id, quantity, unit_price, subtotal, metadata
`

type CreateInvoiceItemParams struct {
	InvoiceID pgtype.UUID    `json:"invoice_id"`
	VersionID pgtype.UUID    `json:"version_id"`
	Quantity  int32          `json:"quantity"`
	UnitPrice pgtype.Numeric `json:"unit_price"`
	Subtotal  pgtype.Numeric `json:"subtotal"`
}

func (q *Queries) CreateInvoiceItem(ctx context.Context, arg CreateInvoiceItemParams) (InvoiceItem, error) {
	row := q.db.QueryRow(ctx, createInvoiceItem,
		arg.InvoiceID,
		arg.VersionID,
		arg.Quantity,
		arg.UnitPrice,
		arg.Subtotal,
	)
	var i InvoiceItem
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.VersionID,
		&i.Quantity,
		&i.UnitPrice,
		&i.Subtotal,
		&i.Metadata,
	)
	return i, err
}

type CreateMultipleInvoiceItemsParams struct {
	ID        pgtype.UUID    `json:"id"`
	InvoiceID pgtype.UUID    `json:"invoice_id"`
	VersionID pgtype.UUID    `json:"version_id"`
	Quantity  int32          `json:"quantity"`
	UnitPrice pgtype.Numeric `json:"unit_price"`
	Subtotal  pgtype.Numeric `json:"subtotal"`
}

const getInvoiceItemsByInvoiceID = `-- name: GetInvoiceItemsByInvoiceID :many
SELECT it.id, invoice_id, version_id, quantity, unit_price, subtotal, metadata, pv.id, product_id, branch_id, name, price_adjustment, attributes, stock_quantity, reorder_point, created_at FROM invoice_items it
JOIN product_versions pv ON pv.id = it.version_id
WHERE it.invoice_id = $1
`

type GetInvoiceItemsByInvoiceIDRow struct {
	ID              pgtype.UUID        `json:"id"`
	InvoiceID       pgtype.UUID        `json:"invoice_id"`
	VersionID       pgtype.UUID        `json:"version_id"`
	Quantity        int32              `json:"quantity"`
	UnitPrice       pgtype.Numeric     `json:"unit_price"`
	Subtotal        pgtype.Numeric     `json:"subtotal"`
	Metadata        []byte             `json:"metadata"`
	ID_2            pgtype.UUID        `json:"id_2"`
	ProductID       pgtype.UUID        `json:"product_id"`
	BranchID        pgtype.UUID        `json:"branch_id"`
	Name            string             `json:"name"`
	PriceAdjustment pgtype.Numeric     `json:"price_adjustment"`
	Attributes      []byte             `json:"attributes"`
	StockQuantity   pgtype.Int4        `json:"stock_quantity"`
	ReorderPoint    pgtype.Int4        `json:"reorder_point"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetInvoiceItemsByInvoiceID(ctx context.Context, invoiceID pgtype.UUID) ([]GetInvoiceItemsByInvoiceIDRow, error) {
	rows, err := q.db.Query(ctx, getInvoiceItemsByInvoiceID, invoiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInvoiceItemsByInvoiceIDRow{}
	for rows.Next() {
		var i GetInvoiceItemsByInvoiceIDRow
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceID,
			&i.VersionID,
			&i.Quantity,
			&i.UnitPrice,
			&i.Subtotal,
			&i.Metadata,
			&i.ID_2,
			&i.ProductID,
			&i.BranchID,
			&i.Name,
			&i.PriceAdjustment,
			&i.Attributes,
			&i.StockQuantity,
			&i.ReorderPoint,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInvoiceItem = `-- name: UpdateInvoiceItem :one
UPDATE invoice_items 
SET 
    version_id = $2, 
    quantity = $3, 
    unit_price = $4, 
    subtotal = $5
WHERE id = $1 
RETURNING id, invoice_id, version_id, quantity, unit_price, subtotal, metadata
`

type UpdateInvoiceItemParams struct {
	ID        pgtype.UUID    `json:"id"`
	VersionID pgtype.UUID    `json:"version_id"`
	Quantity  int32          `json:"quantity"`
	UnitPrice pgtype.Numeric `json:"unit_price"`
	Subtotal  pgtype.Numeric `json:"subtotal"`
}

func (q *Queries) UpdateInvoiceItem(ctx context.Context, arg UpdateInvoiceItemParams) (InvoiceItem, error) {
	row := q.db.QueryRow(ctx, updateInvoiceItem,
		arg.ID,
		arg.VersionID,
		arg.Quantity,
		arg.UnitPrice,
		arg.Subtotal,
	)
	var i InvoiceItem
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.VersionID,
		&i.Quantity,
		&i.UnitPrice,
		&i.Subtotal,
		&i.Metadata,
	)
	return i, err
}
